        - # --- compose ---
        - function compose!(m::DAMap, m2::DAMap, m1::DAMap; dospin::Bool=true, keep_scalar::Bool=true, work_ref::Vector{<:Union{Float64,ComplexF64}}=prep_work_ref(m1), work_low::Tuple{Vararg{Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}}}=prep_comp_work_low(m), work_prom::Union{Nothing,Tuple{Vararg{Vector{<:ComplexTPS}}}}=prep_comp_work_prom(m,m2,m1))
        -   # DAMap setup:
        0   desc = getdesc(m1)
        0   nv = numvars(desc)
        - 
        0   @assert length(work_ref) >= nv "Incorrect length for work_ref, received $(length(work_ref)) but should be atleast $nv"
        -   ref = work_ref
        - 
        0   if keep_scalar
        -     # Take out scalar part and store it
        0     for i=1:nv
        0         @inbounds ref[i] = m1.x[i][0]
        0         @inbounds m1.x[i][0] = 0
        0     end
        -   else
        0     for i=1:nv
        0       @inbounds m1.x[i][0] = 0
        0     end
        -   end
        - 
        0   compose_it!(m, m2, m1, dospin=dospin, work_low=work_low, work_prom=work_prom)
        - 
        -   # Put back the reference and if m1 === m2, also add to outx
        0   if keep_scalar
        0     if m1 === m2
        0       for i=1:nv
        0           @inbounds m1.x[i][0] = ref[i]
        0           @inbounds m.x[i][0] += ref[i]
        0       end
        -     else
        0       for i=1:nv
        0           @inbounds m1.x[i][0] = ref[i]
        0       end
        -     end
        -   end
        - 
        0   return m
        - end
        - 
        - function compose!(m::TPSAMap, m2::TPSAMap, m1::TPSAMap; dospin::Bool=true, work_low::Tuple{Vararg{Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}}}=prep_comp_work_low(m), work_prom::Union{Nothing,Tuple{Vararg{Vector{<:ComplexTPS}}}}=prep_comp_work_prom(m,m2,m1))
        -   # TPSAMap setup:
        -   # For TPSA Map concatenation, we need to subtract w_0 (m2 x0) (Eq. 33)
        -   # Because we are still expressing in terms of z_0 (m1 x0)
        -   desc = getdesc(m1)
        -   nv = numvars(desc)
        -   for i=1:nv
        -     @inbounds m1.x[i][0] -= m2.x0[i]
        -   end
        - 
        -   compose_it!(m, m2, m1, dospin=dospin, work_low=work_low, work_prom=work_prom)
        - 
        -   # Now fix m1 and if m2 === m1, add to output too:
        -   # For TPSA Map concatenation, we need to subtract w_0 (m2 x0) (Eq. 33)
        -   # Because we are still expressing in terms of z_0 (m1 x0)
        -   if m1 === m2
        -     for i=1:nv
        -        @inbounds m1.x[i][0] += m2.x0[i]
        -        @inbounds m.x[i][0] += m2.x0[i]
        -     end
        -   else
        -     for i=1:nv
        -        @inbounds m1.x[i][0] += m2.x0[i]
        -     end
        -   end
        - 
        -   return m
        - end
        - 
        - # --- inverse ---
        - minv!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, mc::Vector{Ptr{RTPSA}}) = (@inline; GTPSA.mad_tpsa_minv!(na, ma, nb, mc))
        - minv!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, mc::Vector{Ptr{CTPSA}}) = (@inline; GTPSA.mad_ctpsa_minv!(na, ma, nb, mc))
        - 
        - 
        - function inv(m1::TaylorMap{S,T,U,V}; dospin::Bool=true, work_ref::Union{Nothing,Vector{<:Union{Float64,ComplexF64}}}=nothing, work_low::Tuple{Vararg{Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}}}=prep_inv_work_low(m1)) where {S,T,U,V}
        -   m = zero(m1)
        -   inv!(m,m1,dospin=dospin,work_ref=work_ref,work_low=work_low)
        -   return m
        - end
        - 
        - function inv!(m::TaylorMap{S,T,U,V}, m1::TaylorMap{S,T,U,V}; dospin::Bool=true, work_ref::Union{Nothing,Vector{<:Union{Float64,ComplexF64}}}=nothing, work_low::Tuple{Vararg{Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}}}=prep_inv_work_low(m1)) where {S,T,U,V}
        0   desc = getdesc(m1)
        0   nn = numnn(desc)
        0   nv = numvars(desc)
        - 
        0   outx_low = work_low[1]
        0   m1x_low = work_low[2]
        0   @assert length(outx_low) >= nn "Cannot inv!: incorrect length for outx_low = work_low[1]. Received $(length(outx_low)), must be >= $nn"
        0   @assert length(m1x_low) >= nn "Cannot inv!: incorrect length for m1x_low = work_low[2]. Received $(length(m1x_low)), must be >= $nn"
        0   if !isnothing(m.Q) && dospin
        0     outQ_low = work_low[3]
        0     @assert length(outQ_low) >= 4 "Cannot inv!: incorrect length for outQ_low = work_low[3]. Received $(length(outQ_low)), must be >= 4"
        0     @assert !(outQ_low === outx_low) "Cannot inv!: outQ_low === outx_low !! outx_low must NOT be reused!"
        -   end
        -   
        -   # if aliasing, must use vector to store x0
        0   if m1 === m
        -     if isnothing(work_ref)
        0       ref = Vector{numtype(T)}(undef, nv)
        -     else
        -       ref = work_ref
        -       @assert length(ref) >= nv "Cannot inv!: incorrect length for ref. Received $(length(ref)), must be >= $nv"
        -     end
        0     map!(t->t[0], ref, view(m1.x,1:nv))
        -   elseif !isnothing(work_ref)
        -     @warn "work_ref provided to inv!, but !(m1 === m)"
        -   end
        - 
        -   # add immutable parameters to outx
        0   @inbounds m.x[nv+1:nn] = view(m1.x, nv+1:nn)
        - 
        0   map!(t->t.tpsa, m1x_low, m1.x)
        0   map!(t->t.tpsa, outx_low, m.x)
        - 
        -   # This C function ignores the scalar part so no need to take it out
        0   minv!(nn, m1x_low, nv, outx_low)
        - 
        -   # Now do quaternion: inverse of q(z0) is q^-1(M^-1(zf))
        0   if !isnothing(m.Q) && dospin
        0     inv!(m.Q, m1.Q)
        0     map!(t->t.tpsa, outQ_low, m.Q.q)
        0     compose!(Cint(4), outQ_low, nn, outx_low, outQ_low)
        -   end
        - 
        0   if m1 === m
        0     for i=1:nv
        0       @inbounds m.x[i][0] = m1.x0[i]
        0       @inbounds m.x0[i] = ref[i]
        0     end
        -   else
        0     for i=1:nv
        0        @inbounds m.x0[i] = m1.x[i][0]
        0        @inbounds m.x[i][0] = m1.x0[i]
        0     end
        -   end
        -   
        0   return 
        - end
        - 
        - 
        - for t = (:DAMap, :TPSAMap)
        - @eval begin  
        - 
        - # --- norm ---
        - function norm(m::$t)
        -   n = norm(m.x0) + norm(norm.(m.x))
        -   if !isnothing(m.Q)
        -     n += norm(m.Q.q)
        -   end
        - 
        -   if !isnothing(m.E)
        -     n += norm(m.E)
        -   end
        -   return n
        - end
        - 
        - # --- complex ---
        - function complex(m::$t{S,T,U,V}) where {S,T,U,V}
        -   desc = getdesc(m)
        -   nn = numnn(desc)
        -   nv = numvars(desc)
        -   np = numparams(desc)
        - 
        -   x0 = map(t->complex(t), m.x0)
        -   
        -   x = Vector{ComplexTPS}(undef, nn)
        -   for i=1:nv
        -     @inbounds x[i] = ComplexTPS(m.x[i],use=desc)
        -   end
        - 
        -   # use same parameters if complex already
        -   if T == ComplexTPS
        -     @inbounds x[nv+1:nn] = view(m.x, nv+1:nn)
        -   else
        -     @inbounds x[nv+1:nn] = complexparams(getdesc(first(x)))
        -   end
        - 
        -   if !isnothing(m.Q)
        -     q = Vector{ComplexTPS}(undef, 4)
        -     for i=1:4
        -       @inbounds q[i] = ComplexTPS(m.Q.q[i],use=desc)
        -     end
        -     Q = Quaternion(q)
        -   else
        -     Q = nothing
        -   end
        - 
        -   if !isnothing(m.E)
        -     E = map(t->complex(t), m.E)
        -   else
        -     E = nothing
        -   end
        -   return $t(x0, x, Q, E)
        - end
        - 
        - end
        - end
        - 
        - # --- clear ---
        - function clear!(m::TaylorMap)
        0   nv = numvars(m)
        0   m.x0 .= 0
        0   for i=1:nv
        0     @inbounds clear!(m.x[i])
        0   end
        0   if !isnothing(m.Q)
        0     for i=1:4
        0       @inbounds clear!(m.Q.q[i])
        0     end
        -   end
        -   if !isnothing(m.E)
        -     m.E .= 0
        -   end
        0   return
        - end
        - 
        - # --- cut ---
        - function cut(m1::TaylorMap{S,T,U,V}, order::Integer; dospin::Bool=true) where {S,T,U,V}
        -   m = zero(m1)
        -   cut!(m, m1, order, dospin=dospin)
        -   return m
        - end
        - 
        - function cut!(m::TaylorMap{S,T,U,V}, m1::TaylorMap{S,T,U,V}, order::Integer; dospin::Bool=true) where {S,T,U,V}
        0   desc = getdesc(m1)
        0   nv = numvars(desc)
        -   np = numparams(desc)
        0   nn = numnn(desc)
        0   m.x0 .= m1.x0
        0   for i=1:nv
        0     @inbounds cutord!(m.x[i], m1.x[i], order)
        -     #GTPSA.cutord!(m1.x[i].tpsa, m.x[i].tpsa, convert(Cint, ord))
        0   end
        -   # add immutable parameters to outx
        0   @inbounds m.x[nv+1:nn] = view(m1.x, nv+1:nn)
        - 
        0   if !isnothing(m1.Q) && dospin
        0     for i=1:4
        0       @inbounds cutord!(m.Q.q[i], m1.Q.q[i], order)
        -       #@inbounds GTPSA.cutord!(m1.Q.q[i].tpsa, m.Q.q[i].tpsa, convert(Cint, ord))
        0     end
        -   end
        -   if !isnothing(m1.E)
        -     m.E .= m.E
        -   end
        0   return
        - end

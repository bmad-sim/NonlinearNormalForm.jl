var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NonlinearNormalForm","category":"page"},{"location":"#NonlinearNormalForm","page":"Home","title":"NonlinearNormalForm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NonlinearNormalForm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NonlinearNormalForm]","category":"page"},{"location":"#Base.inv-Tuple{Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"Base.inv","text":"inv(ma::Vector{<:Union{TPS,ComplexTPS}})\n\nInverts the map ma such that ma ∘ inv(ma) = 1 in the variables.\n\nExample\n\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf, [x, p]);\n\njulia> map ∘ inv(map)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   1.0000000000000000e+00      1      1   0\n-------------------------------------------------\n   2:   1.0000000000000002e+00      1      0   1\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{DAMap, DAMap, DAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; dospin=true, work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nwork_low[1] = outx_low   # Length >= nv\nwork_low[2] = m2x_low    # Length >= nv\nwork_low[3] = m1x_low    # Length >= nv+np\nwork_low[4] = outQ_low   # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\nwork_low[5] = m2Q_low    # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary ComplexTPSs if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): work_prom[1] = m1x_prom  # Length >= nv+np, Vector{ComplexTPS}\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted):\n\nwork_prom[1] = m2x_prom  # Length >= nv, Vector{ComplexTPS}\nwork_prom[2] = m2Q_prom  # Length >= 4, Vector{ComplexTPS}\n\nNote that the ComplexTPSs in the vector(s) must be allocated and have the same Descriptor.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{TPSAMap, TPSAMap, TPSAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; dospin=true, work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nwork_low[1] = outx_low   # Length >= nv\nwork_low[2] = m2x_low    # Length >= nv\nwork_low[3] = m1x_low    # Length >= nv+np\nwork_low[4] = outQ_low   # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\nwork_low[5] = m2Q_low    # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary ComplexTPSs if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): work_prom[1] = m1x_prom  # Length >= nv+np, Vector{ComplexTPS}\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted):\n\nwork_prom[1] = m2x_prom  # Length >= nv, Vector{ComplexTPS}\nwork_prom[2] = m2Q_prom  # Length >= 4, Vector{ComplexTPS}\n\nNote that the ComplexTPSs in the vector(s) must be allocated and have the same Descriptor.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.exppb","page":"Home","title":"NonlinearNormalForm.exppb","text":"exppb(F::Vector{<:Union{TPS,ComplexTPS}}, m::Vector{<:Union{TPS,ComplexTPS}}=vars(first(F)))\n\nCalculates exp(F⋅∇)m = m + F⋅∇m + (F⋅∇)²m/2! + .... If m is not provided, it is assumed  to be the identity. \n\nExample\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf, [x, p])\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   9.9001665555952290e-01      1      1   0\n   1:   9.9666999841313930e-01      1      0   1\n-------------------------------------------------\n   2:  -1.9933399968262787e-02      1      1   0\n   2:   9.9001665555952378e-01      1      0   1\n\n\n\n\n\n","category":"function"},{"location":"#NonlinearNormalForm.fgrad-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.fgrad","text":"fgrad(F::Vector{<:Union{TPS,ComplexTPS}}, g::Union{TPS,ComplexTPS})\n\nCalculates F⋅∇g.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.gethamiltonian-Tuple{Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"NonlinearNormalForm.gethamiltonian","text":"gethamiltonian(F::Vector{<:Union{TPS,ComplexTPS}})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), this function calculates the Hamiltonian  from a vector field F that can be obtained from a Hamiltonian (e.g. by getvectorfield). Explicitly,  ∫ F₁ dp₁ - ∫ F₂ dq₁ + ... + ∫ F₂ₙ₋₁ dpₙ - ∫ F₂ₙ dqₙ\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> h = (x[1]^2 + x[2]^2)/2\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\njulia> F = getvectorfield(h)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\njulia> gethamiltonian(F)\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.getvectorfield-Tuple{Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.getvectorfield","text":"getvectorfield(h::Union{TPS,ComplexTPS})::Vector{<:typeof(h)}\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [∂h/∂p₁, -∂h/∂q₁, ...]\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> h = (x[1]^2 + x[2]^2)/2\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\njulia> getvectorfield(h)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.lb-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"NonlinearNormalForm.lb","text":"lb(A::Vector{<:Union{TPS,ComplexTPS}}, F::Vector{<:Union{TPS,ComplexTPS}})\n\nComputes the Lie bracket of the vector functions A and F, defined over N variables as  Σᵢᴺ Aᵢ (∂F/∂xᵢ) - Fᵢ (∂A/∂xᵢ)\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> A = [-x[2], x[1]]\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\njulia> F = [-x[1]^2, 2*x[1]*x[2]]\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      2      2   0\n-------------------------------------------------\n   2:   2.0000000000000000e+00      2      1   1\n\n\njulia> lb(A,F)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   4.0000000000000000e+00      2      1   1\n-------------------------------------------------\n   2:   3.0000000000000000e+00      2      2   0\n   2:  -2.0000000000000000e+00      2      0   2\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.logpb","page":"Home","title":"NonlinearNormalForm.logpb","text":"logpb(mf::Vector{<:Union{TPS,ComplexTPS}}, mi::Vector{<:Union{TPS,ComplexTPS}}=vars(first(F)))\n\nGiven a final map mf and initial map mi, this function calculates the vector field F such that mf=exp(F⋅∇)mi. If mi is not provided, it is assumed to be the identity.\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf);\n\njulia> logpb(map) == -time*hf\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#NonlinearNormalForm.pb-Tuple{Union{ComplexTPS, TPS}, Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.pb","text":"pb(f::Union{TPS, ComplexTPS}, g::Union{TPS, ComplexTPS})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), computes the Poisson bracket  of the scalar functions f and g. The Poisson bracket of two functions {f, g} is defined as  Σᵢ (∂f/∂qᵢ)(∂g/∂pᵢ) - (∂g/∂qᵢ)(∂f/∂pᵢ).\n\nExamples\n\njulia> d = Descriptor(4,10);\n\njulia> x = vars(d);\n\njulia> f = (x[1]^2 + x[2]^2)/2 + (x[3]^2 + x[4]^2)/2;\n\njulia> pb(f,x[1])\nTPS:\n  Coefficient              Order     Exponent\n  -1.0000000000000000e+00    1        0    1    0    0\n\n\njulia> pb(f,x[2])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0    0    0\n\n\njulia> pb(f,x[3])\nTPS:\n  Coefficient              Order     Exponent\n  -1.0000000000000000e+00    1        0    0    0    1\n\n\njulia> pb(f,x[4])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    0    1    0\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.ptinv-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Vector{<:Integer}}","page":"Home","title":"NonlinearNormalForm.ptinv","text":"ptinv(ma::Vector{<:Union{TPS,ComplexTPS}}, vars::Vector{<:Integer})\n\nPartially-inverts the map ma, inverting only the variables specified by index in vars.\n\n\n\n\n\n","category":"method"}]
}

var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NonlinearNormalForm","category":"page"},{"location":"#NonlinearNormalForm","page":"Home","title":"NonlinearNormalForm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NonlinearNormalForm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NonlinearNormalForm]","category":"page"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{DAMap, DAMap, DAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nworklow[1] = outxlow   # Length >= nv worklow[2] = m2xlow    # Length >= nv worklow[3] = m1xlow    # Length >= nv+np worklow[4] = outQlow   # Length >= 4, could be = worklow[1] or worklow[2] if nv >= 4 worklow[5] = m2Qlow    # Length >= 4, could be = worklow[1] or worklow[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary vectors if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): workprom[1] = m1xprom  # Length >= nv+np, could be = Vector{ComplexTPS}(undef, nv+np)\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted): workprom[1] = m2xprom  # Length >= nv, could be = Vector{ComplexTPS}(undef, nv) workprom[2] = m2Qprom  # Length >= 4, could be = Vector{ComplexTPS}(undef, 4)\n\nNote that the ComplexTPSs in the vector do NOT need to be defined - just the container should be passed.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{TPSAMap, TPSAMap, TPSAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nworklow[1] = outxlow   # Length >= nv worklow[2] = m2xlow    # Length >= nv worklow[3] = m1xlow    # Length >= nv+np worklow[4] = outQlow   # Length >= 4, could be = worklow[1] or worklow[2] if nv >= 4 worklow[5] = m2Qlow    # Length >= 4, could be = worklow[1] or worklow[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary vectors if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): workprom[1] = m1xprom  # Length >= nv+np, could be = Vector{ComplexTPS}(undef, nv+np)\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted): workprom[1] = m2xprom  # Length >= nv, could be = Vector{ComplexTPS}(undef, nv) workprom[2] = m2Qprom  # Length >= 4, could be = Vector{ComplexTPS}(undef, 4)\n\nNote that the ComplexTPSs in the vector do NOT need to be defined - just the container should be passed.\n\n\n\n\n\n","category":"method"}]
}

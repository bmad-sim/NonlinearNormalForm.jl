var documenterSearchIndex = {"docs":
[{"location":"namespace/#NonlinearNormalForm-Entity-List","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm Entity List","text":"","category":"section"},{"location":"namespace/","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm Entity List","text":"List of entities in the NonlinearNormalForm namespace.","category":"page"},{"location":"namespace/#Index","page":"NonlinearNormalForm Entity List","title":"Index","text":"","category":"section"},{"location":"namespace/","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm Entity List","text":"","category":"page"},{"location":"namespace/#Entity-List","page":"NonlinearNormalForm Entity List","title":"Entity List","text":"","category":"section"},{"location":"namespace/#NonlinearNormalForm.S","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.S","text":"Generic symplectic skew symmetric S matrix (size inferred from  other matrix in operations) using SkewLinearAlgebra's JMatrix\n\n\n\n\n\n","category":"constant"},{"location":"namespace/#NonlinearNormalForm.DAMap","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.DAMap","text":"struct DAMap{V0,V,Q,S} <: TaylorMap{V0,V,Q,S}\n\nMap such that the expansion point is around zero.  See the TaylorMap documentation for details.\n\nFields\n\nv0::V0 – Reference orbit. The entrance coordinates of the map as scalars, or equivalently the Taylor map expansion point.\nv::V   – Orbital ray as truncated power series, expansion around v0, with scalar part equal to EXIT coordinates of map\nq::Q   – Quaternion as truncated power series if spin is included, else nothing\ns::S   – Matrix of the envelope for stochastic kicks as scalars if included, else nothing\n\n\n\n\n\n","category":"type"},{"location":"namespace/#NonlinearNormalForm.SymplecticS","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.SymplecticS","text":"Generic symplectic skew symmetric S matrix (size inferred from  other matrix in operations) using SkewLinearAlgebra's JMatrix\n\n\n\n\n\n","category":"type"},{"location":"namespace/#NonlinearNormalForm.TPSAMap","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.TPSAMap","text":"struct TPSAMap{V0,V,Q,S} <: TaylorMap{V0,V,Q,S}\n\nMap where the expansion point does not have to be around zero.  Includes feed down error if composing maps with different expansion points. See the TaylorMap documentation for details.\n\nFields\n\nv0::V0 – Reference orbit. The entrance coordinates of the map as scalars, or equivalently the Taylor map expansion point.\nv::V   – Orbital ray as truncated power series, expansion around v0, with scalar part equal to EXIT coordinates of map\nq::Q   – Quaternion as truncated power series if spin is included, else nothing\ns::S   – Matrix of the envelope for stochastic kicks as scalars if included, else nothing\n\n\n\n\n\n","category":"type"},{"location":"namespace/#NonlinearNormalForm.TaylorMap","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.TaylorMap","text":"abstract type TaylorMap{V0,V,Q,S}\n\nAbstract type for TPSAMap and DAMap used for normal form analysis. DAMaps have a coordinate  system chosen so that the expansion point is always around zero, e.g. Δv = v, while TPSAMaps  can have any coordinate system/expansion point, but therefore will accrue truncation error when  trying to compose two TPSAMaps with differing expansion points. For normal form analysis of  periodic maps, using a DAMap ensures no truncation error up to the chosen truncation order.\n\nAny truncated power series (TPS) type supported by TPSAInterface.jl is allowed for use in  a TaylorMap. Henceforth we will generically refer to this type as a TPS\n\nFields\n\nv0::V0 – Reference orbit. The entrance coordinates of the map as scalars, or equivalently the Taylor map expansion point.\nv::V   – Orbital ray as truncated power series, expansion around v0, with scalar part equal to EXIT coordinates of map\nq::Q   – Quaternion as truncated power series if spin is included, else nothing\ns::S   – Matrix of the envelope for stochastic kicks as scalars if included, else nothing\n\nType Requirements\n\nV0 <: AbstractVector{<:Number} where ismutabletype(V0) == true \nV <: AbstractVector{<:TPS} where TPSAInterface.numtype(V) == eltype(V0)\nQ <: Union{Quaternion{<:TPS},Nothing} and if Q != Nothing then eltype(Q) == eltype(V)\nS <: Union{AbstractMatrix{<:Number},Nothing} where S != Nothing then eltype(S) == TPSAInterface.numtype(eltype(V)) AND ismutabletype(S) == true\n\nBecause the TPS type is mutable and TPSAInterface.jl provides in-place functions for modifying  TPSs, at the lowest level, all operations on TaylorMaps are in-place for performance. Therefore,  the v and q arrays which contain TPSs may be immutable, e.g. the orbital ray v may be an  SVector from the StaticArrays.jl package, and the Quaternion type which is taken from  ReferenceFrameRotations.jl is already immutable. The default for the orbital ray is SVector. The v0 and s arrays contain immutable number types, and so these arrays MUST be mutable.\n\n\n\n\n\n","category":"type"},{"location":"namespace/#NonlinearNormalForm.VectorField","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.VectorField","text":"VectorField{V,Q}\n\nLie operator which acts on DAMaps e.g. dM/dt = FM where F is the VectorField and  M is the DAMap. F can be promoted to a DAMap using exp(F).\n\nFields\n\nv::V – Orbital ray as truncated power series, expansion with scalar part equal to EXIT coordinates of map\nq::Q – Quaternion as truncated power series if spin is included, else nothing\n\nType Requirements\n\nV <: AbstractVector{<:TPS}\nQ <: Union{Quaternion{<:TPS},Nothing} and if Q != Nothing then eltype(Q) == eltype(V)\n\n\n\n\n\n","category":"type"},{"location":"namespace/#Base.one-Tuple{TaylorMap}","page":"NonlinearNormalForm Entity List","title":"Base.one","text":"one(m::TaylorMap)\n\nCreates an identity m with the same properties as m, including GTPSA Descriptor, spin, and stochasticity.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#Base.zero-Tuple{TaylorMap}","page":"NonlinearNormalForm Entity List","title":"Base.zero","text":"zero(m::TaylorMap)\n\nCreates a zero m with the same properties as m including TPSA definiton, spin, and stochasticity.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.checksymp-Tuple{Any}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.checksymp","text":"checksymp(M)\n\nReturns tranpose(M)*S*M - S, where S is the skew-symmetric matrix  S = blkdiag([0 1; -1 0], ...). If M is symplectic, then the result should be a matrix  containing all zeros. The non-symplectic parts of the matrix can be identified  by those nonzero elements in the result.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.exp!-Tuple{DAMap, VectorField, Union{LinearAlgebra.UniformScaling, DAMap}}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.exp!","text":"exp!(\n  m::DAMap, \n  F::VectorField, \n  m1::DAMap; \n  work_maps::NTuple{2, DAMap}=ntuple(t->zero(m1), Val{2}()), \n  work_q::Union{Quaternion,Nothing}=isnothing(m.q) ? nothing : zero(m.q)\n)\n\nComputes exp(F)*m1, and stores the result in m. Explicity, this is exp(F)*m1 = m1 + F*m1 + 1/2*F*(F*m1) + 1/6*F*(F*(F*m1)) + ..., where * is the operation of a VectorField on the map. See the documentation for mul! for  more details of this operation. If the linear part of F is zero, then the  number of iterations is equal to the number of higher orders left.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.is_orbital_resonance-NTuple{5, Any}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.is_orbital_resonance","text":"is_orbital_resonance(varidx, ords, nhv, res, spin_res)\n\nChecks if the monomial corresponds to a particular resonance  (and resonance in the same family)\n\nNote that for 3Q_x = integer, we also have 6Q_x though where \n\nlambda(3Q_x) = integer where lambda*3 <= MAXORD + 1 according to notes are in the same family and so these must be left in too. These are the same family\n\neach column of resonance corresponds to one res in the family\n\nEach row is a multiple of previous\n\nSo For example for the 1Q_1 + 2Q2 + 3*Q3 = integer resonance: m =  [ 1  2  3  ...;   2  4  6  ...;   3  6  9  ...];\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.is_spin_resonance-NTuple{5, Any}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.is_spin_resonance","text":"nu_s + j dot Q = n\n\n0Qx + 1Qy + 2*Qs = n\n\nIMPORTANT:::: For spin resonances, there is only one resonance in each resonance family:\n\nm = [0 ;      1  ]\n\nms = [1];\n\nIn the code, check - of m + ms\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.is_tune_shift","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.is_tune_shift","text":"is_tune_shift(varidx, ords, nhv, hamiltonian=false)\n\nChecks if the monomial corresponds to a tune shift.\n\nInput\n\nvaridx      – Current variable index (e.g. 1 is v, 2 is px, etc)\nords        – Array of monomial index as orders\nnhv         – Number harmonic variables\nhamiltonian – Default is false, if the monomial is in a vector field and not a hamitlonian then this should be false.\n\n\n\n\n\n","category":"function"},{"location":"namespace/#NonlinearNormalForm.lb!-Tuple{VectorField, VectorField, VectorField}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.lb!","text":"lb!(G::VectorField, F::VectorField, H::VectorField; work_q::Union{Nothing,Quaternion}=nothing) -> G\n\nSets G equal to the Lie bracket of the vector fields F and H. Explicitly, including  spin (with the lower case letter for the quaternion of the vector field), this is:\n\n(G,g) = ⟨(F,f) , (H,h)⟩ = (F⋅∇H-H⋅∇F , [h,f]+F⋅∇h-G⋅∇f)\n\nwhere [h,f] = h*f - f*h is just a quaternion commutator. See Equation 44.52 in the Bmad manual\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.locate_modes!","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.locate_modes!","text":"locate_modes!(evecs, evals=nothing; sort=true, modes=nothing)\n\nFor each mode (every pair of rows in evecs), determines the eigenvector (each  column in evecs) with the largest norm in that mode. The eigenvectors must  have dimensionality of 2n, n ∈ ℤ and be next to each other pairs. \n\nIf sort is true, then the pairs of eigenvectors are sorted in-place. The eigenvalues will also be  sorted if evals is provided. If sort is false, then the modes vector is filled with a mapping  of the current eigenvector position to its mode (index of modes is the current eigenvector  position, and the element at that index in modes is the mode that it corresponds to). For  sort=true, modes == 1:n after calling this function.\n\nIf the mode locating is successful, true is returned. For unsuccessful mode locating,  false is returned, modes will contain junk, and the eigenvectors/values may be partially sorted.\n\nAssumes the eigenvectors (and eigenvalues if provided) are already in pairs (next to  each other) starting at the first column.\n\nInput:\n\nevecs  – 2n x 2n matrix of eigenvectors already in pairs\nevals  – Vector of length 2n containing the eigenvalues corresponding to the eigenvectors in evecs\nsort   – (Optional) kwarg to specify whether or not to sort the eigenvectors, default is true\n\nOutput:\n\nret    – Returns true if the mode locating is successful, false if otherwise\nmodes – (Optional) kwarg for eigvec -> mode mapping, length(evecs) == Int(size(evecs,1)/2)\n\n\n\n\n\n","category":"function"},{"location":"namespace/#NonlinearNormalForm.log!-Tuple{VectorField, DAMap}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.log!","text":"log!(\n  F::VectorField, \n  m1::DAMap; \n  work_maps::NTuple{3, DAMap}=ntuple(t->zero(m1), Val{3}()),\n  work_vfs::NTuple{2, VectorField}=ntuple(t->zero(F), Val{2}()),\n  work_q::Union{Quaternion,Nothing}=isnothing(m1.q) ? nothing : zero(m1.q)\n)\n\nComputes the log of the map m1 - that is, calculates the VectorField F that  would represent the map m1 as a Lie exponent exp(F) - and stores the result in F. The map m1 should be close to the identity for this to converge quickly.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.mat_eigen!-Tuple{Any}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.mat_eigen!","text":"mat_eigen!(mat; sort=true, phase_modes=true)\n\nSame as mat_eigen, but mutates mat for speed. See the documentation for mat_eigen  for more details.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.mat_eigen-Tuple{Any}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.mat_eigen","text":"mat_eigen(mat; sort=true, phase_modes=true)\n\nGiven a matrix mat with an even number of rows/cols, calculates the eigenvectors  and eigenvalues. For stable eigenmodes (complex conjugate eigenvector/eigenvalue pairs),  the eigenvectors are normalized so that vⱼ'*S*vⱼ = +im for odd j, and -im for even j.\n\nIf sort is true, then each eigenvector/eigenvalue pair will be sorted according to the mode  it best identifies with. A warning will be printed if the mode sorting fails. Mode sorting  will automatically fail if more than 1 mode is unstable. Default is true.\n\nIf phase_modes is true, then each stable mode will be multiplied by a phase factor to make  the first component of that mode (e.g. the x, y, or z component, NOT the px, py, or pz component)  be fully real. This both makes the eigenvector \"pretty\", and in this case of weak coupling, ensures  that vⱼ'*vⱼ₊₁ for j in (1, 3, 5) has a positive imaginary part so that the eigenvectors/eigenvalues  for odd j are associated with the positive tune and even j the negative tune. This  phase factor is harmless/useless to include in a highly-coupled matrix.\n\nFor complex matrices, Julia's eigen, which is called by mat_eigen, is type-unstable.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.moveback_unstable!-Tuple{LinearAlgebra.Eigen}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.moveback_unstable!","text":"moveback_unstable!(F::Eigen) -> Int\n\nMoves back eigenvectors with eigenvalues having a zero imaginary component to the end of  the values and vectors arrays in the Eigen struct, and returns the number of unstable  eigenvectors. \n\nNote that if more than 1 mode is unstable, the pair of eigenvectors corresponding to a mode  will not necessarily be next to each other at the end of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.mul!-Tuple{DAMap, VectorField, DAMap}","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.mul!","text":"mul!(m::DAMap, F::VectorField, m1::DAMap; work_q::Union{Quaternion,Nothing}=isnothing(m.q) ? nothing : zero(m.q)) -> m\n\nComputes the Lie operator F acting on a DAMap m1, and stores the result in m. Explicity, that is F * m = (F.v, F.q) * (m.v, m.q) = (F.v ⋅ ∇ m.v , F.v ⋅ ∇ m.q + m.q*F.q)\n\n\n\n\n\n","category":"method"},{"location":"namespace/#NonlinearNormalForm.normalize_eigenmode!","page":"NonlinearNormalForm Entity List","title":"NonlinearNormalForm.normalize_eigenmode!","text":"normalize_eigenmode!(evec_pair, eval_pair, phase_mode::Integer=-1)\n\nNormalizes the complex-conjugate eigenvector pair so that vⱼ'*S*vⱼ = +im  for j=1, and -im for j=2. This may involve swapping the complex-conjugate  eigenvectors/eigenvalues.\n\nIf phase_mode is set to a particular mode (1, 2, 3), then a phase will be multiplied by the  eigenvectors to make them \"pretty\"; the phase will make the first component of that mode (e.g.  the x, y, or z component) be fully real. This gives the eigenvectors a simple form in the  weakly-coupled case, with the product v₁'*v₂ having a positive imaginary part, and ensures the  odd numbered eigenvector/eigenvalues are associated with the tune and the even numbered ones have  the negative of the tune. In cases with a lot of coupling, there is no simple way to define the  positive or negative tune, and multiplying by this phase factor is harmless. See the \"Tunes From  One-Turn Matrix Eigen Analysis\" section in the Bmad manual for more details. \n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package can be used for doing perturbation theory with nonlinear, parametric Hamiltonian maps using Lie algebraic methods. Maps with large damping can be handled. Given a map expressed as a truncated power series in small deviations of the variables and parameters, this package can be used to calculate and analyze the canonical transformation to the normal form – coordinates where the motion lies on action-dependent circles in phase space or contains a single resonance. This allows for easy calculation of all important (parameter-dependent) properties of the map. Furthermore, by extending the Lie algebra to include a quaternion operator in the vector field, the spin normal form analysis can be performed in the same way as the orbital. This fully unifies spin and orbital one-resonance normal form calculations, without needing to learn two different theories, and allows for analysis of time-dependent Hamiltonians via Deprit-like algorithms. The package is used in the SciBmad accelerator physics ecosystem for all analysis, and may also be of interest in fields such as celestial mechanics, electronic circuits, electron microscopy, geometrical optics, and plasma physics.","category":"page"},{"location":"#Setup","page":"Introduction","title":"Setup","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use this package, in the Julia REPL run:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg; Pkg.add(url=\"https://github.com/bmad-sim/NonlinearNormalForm.jl\")","category":"page"},{"location":"#Basic-Usage","page":"Introduction","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package includes real and complex differential algebraic (DA) maps with properly overloaded operators, map composition and inversion, parametric normal form calculation routines optionally including a \"coasting\" plane (including a constant \"energy-like\" canonical variable), factorization of the normalizing map, Lie operators including a quaternion for spin, calculations such as exp of Lie operators to construct Lie maps or the log of Lie maps to obtain the Lie operator, and one resonance normal form analysis tools.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"After a DAMap is calculated via tracking of a truncated power series, the map can be analyzed using the routines here. Some example maps randomly generated by FPP are provided in the test directory.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> m = DAMap(v=v, q=q) # make a DA map from orbital ray (v) and optionally spin quaternion (q)\n\njulia> m_lin = cutord(m, 2); # extract the linear part in orbital\n\njulia> m_nonlinear = inv(m_lin) ∘ m; # remove the linear part\n\njulia> F = log(m_nonlinear); # Get the Lie operator (including quaternion) generating nonlinear part\n\njulia> m = m_lin ∘ exp(F);  # Reconstruct same map using Lie exponent and linear part separately\n\njulia> a = normal(m);  # Calculate the nonlinear (parametric) normalizing canonical transformation\n\njulia> R_z = inv(a) ∘ m ∘ a; # Nonlinear amplitude-dependent rotation in regular phase space (x, px, …)\n\njulia> c = c_map(m);  # Get the transform to phasors basis √(J)*exp(±im*ϕ)\n\njulia> R_J = inv(c) ∘ R_z ∘ c; # Nonlinear amplitude-dependent rotation in phasors basis\n\njulia> a_spin, a0, a1, a2 = factorize(a); # Spin part, nonlinear parameter-dependent fixed point, a1, a2\n\njulia> Σ = equilibrium_moments(m, a); # Calculate equilibrium sigma matrix when fluctuation-dissipation\n\njulia> a = normal(m, m=[0; 1], m_spin=[-1]);  # Leaving in a Q_y - Q_spin resonance","category":"page"},{"location":"#History-and-Acknowledgement","page":"Introduction","title":"History and Acknowledgement","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This NonlinearNormalForm package is inspired by the Full Polymorphic Package (FPP) library written by Etienne Forest (AKA Patrice Nishikawa) in Fortran90. Much thanks must go to Etienne for his time and patience in teaching the normal form methods and guiding the implementation of the tools in this package.","category":"page"}]
}

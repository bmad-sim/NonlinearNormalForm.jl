var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NonlinearNormalForm","category":"page"},{"location":"#NonlinearNormalForm","page":"Home","title":"NonlinearNormalForm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NonlinearNormalForm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NonlinearNormalForm]","category":"page"},{"location":"#Base.inv-Tuple{Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"Base.inv","text":"inv(ma::Vector{<:Union{TPS,ComplexTPS}})\n\nInverts the map ma such that ma ∘ inv(ma) = 1 in the variables.\n\nExample\n\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf, [x, p]);\n\njulia> map ∘ inv(map)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   1.0000000000000000e+00      1      1   0\n-------------------------------------------------\n   2:   1.0000000000000002e+00      1      0   1\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.checksymp-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Number","page":"Home","title":"NonlinearNormalForm.checksymp","text":"checksymp(M::Matrix{T}) where T<:Number\n\nReturns tranpose(M)*S*M - S, where S is the skew-symmetric matrix  S = [0 I; -I 0]. If M is symplectic, then the result should be a matrix  containing all zeros. The non-symplectic parts of the matrix can be identified  by those nonzero elements in the result.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{DAMap, DAMap, DAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; dospin=true, work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nwork_low[1] = outx_low   # Length >= nv\nwork_low[2] = m2x_low    # Length >= nv\nwork_low[3] = m1x_low    # Length >= nv+np\nwork_low[4] = outQ_low   # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\nwork_low[5] = m2Q_low    # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary ComplexTPSs if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): work_prom[1] = m1x_prom  # Length >= nv+np, Vector{ComplexTPS}\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted):\n\nwork_prom[1] = m2x_prom  # Length >= nv, Vector{ComplexTPS}\nwork_prom[2] = m2Q_prom  # Length >= 4, Vector{ComplexTPS}\n\nNote that the ComplexTPSs in the vector(s) must be allocated and have the same Descriptor.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.compose_it!-Tuple{TPSAMap, TPSAMap, TPSAMap}","page":"Home","title":"NonlinearNormalForm.compose_it!","text":"compose_it!(m, m2, m1; dospin=true, work_low=nothing, work_prom=nothing)\n\nLow level composition function, m = m2 ∘ m1. Aliasing m with m2 is allowed, but not m with m1. Assumes the destination map is properly set up (with correct types promoted if necessary), and  that m.x[1:nv] (and m.Q.q if spin) contain allocated TPSs. The parameters part of m.x (m.x[nv+1:nn])  does not need to contain allocated TPSs.\n\nFor all compositions, 5 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  Three vectors are for the orbital part (m.x, m2.x, m1.x correspondingly referred in the code as  outx_low, m2x_low, and m1x_low) and two are for the spin part (m.Q.q and m2.Q.q correspondingly  referred in the code as outQ_low and m2Q_low).  These 5 temporaries can be optionally passed as a tuple  in work_low, and must satisfy the following requirements:\n\nwork_low[1] = outx_low   # Length >= nv\nwork_low[2] = m2x_low    # Length >= nv\nwork_low[3] = m1x_low    # Length >= nv+np\nwork_low[4] = outQ_low   # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\nwork_low[5] = m2Q_low    # Length >= 4, could be = work_low[1] or work_low[2] if nv >= 4\n\nFurthermore, for the spin part both of outx_low and m2x_low could be reused for outQ_low and m2Q_low  if nv >= 4 , however m1x_low MUST NOT BE REUSED!\n\nIf promotion is occuring, then one of the maps is ComplexTPS and the other TPS, with output map ComplexTPS.  Note that the spin part is required to agree with the orbital part in terms of type by definition of the TaylorMap  struct. work_prom can optionally be passed as a tuple containing the temporary ComplexTPSs if promotion is occuring:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): work_prom[1] = m1x_prom  # Length >= nv+np, Vector{ComplexTPS}\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted):\n\nwork_prom[1] = m2x_prom  # Length >= nv, Vector{ComplexTPS}\nwork_prom[2] = m2Q_prom  # Length >= 4, Vector{ComplexTPS}\n\nNote that the ComplexTPSs in the vector(s) must be allocated and have the same Descriptor.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.exppb","page":"Home","title":"NonlinearNormalForm.exppb","text":"exppb(F::Vector{<:Union{TPS,ComplexTPS}}, m::Vector{<:Union{TPS,ComplexTPS}}=vars(first(F)))\n\nCalculates exp(F⋅∇)m = m + F⋅∇m + (F⋅∇)²m/2! + .... If m is not provided, it is assumed  to be the identity. \n\nExample\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf, [x, p])\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   9.9001665555952290e-01      1      1   0\n   1:   9.9666999841313930e-01      1      0   1\n-------------------------------------------------\n   2:  -1.9933399968262787e-02      1      1   0\n   2:   9.9001665555952378e-01      1      0   1\n\n\n\n\n\n","category":"function"},{"location":"#NonlinearNormalForm.fgrad-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.fgrad","text":"fgrad(F::Vector{<:Union{TPS,ComplexTPS}}, g::Union{TPS,ComplexTPS})\n\nCalculates F⋅∇g.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.gethamiltonian-Tuple{Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"NonlinearNormalForm.gethamiltonian","text":"gethamiltonian(F::Vector{<:Union{TPS,ComplexTPS}})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), this function calculates the Hamiltonian  from a vector field F that can be obtained from a Hamiltonian (e.g. by getvectorfield). Explicitly,  ∫ F₁ dp₁ - ∫ F₂ dq₁ + ... + ∫ F₂ₙ₋₁ dpₙ - ∫ F₂ₙ dqₙ\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> h = (x[1]^2 + x[2]^2)/2\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\njulia> F = getvectorfield(h)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\njulia> gethamiltonian(F)\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.getvectorfield-Tuple{Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.getvectorfield","text":"getvectorfield(h::Union{TPS,ComplexTPS})::Vector{<:typeof(h)}\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [∂h/∂p₁, -∂h/∂q₁, ...]\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> h = (x[1]^2 + x[2]^2)/2\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e-01      2      2   0\n  5.0000000000000000e-01      2      0   2\n\n\njulia> getvectorfield(h)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.lb-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Vector{<:Union{ComplexTPS, TPS}}}","page":"Home","title":"NonlinearNormalForm.lb","text":"lb(A::Vector{<:Union{TPS,ComplexTPS}}, F::Vector{<:Union{TPS,ComplexTPS}})\n\nComputes the Lie bracket of the vector functions A and F, defined over N variables as  Σᵢᴺ Aᵢ (∂F/∂xᵢ) - Fᵢ (∂A/∂xᵢ)\n\nExample\n\njulia> d = Descriptor(2,10); x = vars();\n\njulia> A = [-x[2], x[1]]\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      1      0   1\n-------------------------------------------------\n   2:   1.0000000000000000e+00      1      1   0\n\n\njulia> F = [-x[1]^2, 2*x[1]*x[2]]\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:  -1.0000000000000000e+00      2      2   0\n-------------------------------------------------\n   2:   2.0000000000000000e+00      2      1   1\n\n\njulia> lb(A,F)\n2-element Vector{TPS}:\n  Out  Coefficient                Order   Exponent\n-------------------------------------------------\n   1:   4.0000000000000000e+00      2      1   1\n-------------------------------------------------\n   2:   3.0000000000000000e+00      2      2   0\n   2:  -2.0000000000000000e+00      2      0   2\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.locate_planes!-Tuple{Union{LinearAlgebra.Eigen, Matrix}}","page":"Home","title":"NonlinearNormalForm.locate_planes!","text":"locate_planes!(F::Union{Matrix,Eigen}; sort::Bool=true, planes::Union{Vector{Int},Nothing}=nothing)\n\nFor each plane (every pair of rows in F or F.vectors), determines the eigenvector  (each column in F or F.vectors) with the largest norm in that plane. The eigenvectors  must have dimensionality of 2n, n ∈ ℤ.\n\nIf sort is true, then the eigenvectors are sorted in-place. The eigenvalues will also be  sorted if F isa Eigen. If sort is false, then the planes vector is filled with a mapping  of the current eigenvector position to its plane (index of planes is the current eigenvector  position, and the element at that index in planes is the  plane that it corresponds to). For  sort=true, planes == 1:n after calling this function.\n\nIf the plane locating is successful, true is returned. For unsuccessful plane locating,  false is returned, planes will contain junk, and the eigenvectors may be partially sorted.\n\nAssumes the eigenvectors (and eigenvalues if F isa Eigen) in F are already in pairs (next to  each other) starting at the first column.\n\nInput:\n\nF      – 2n x 2n matrix of eigenvectors already in pairs, or an Eigen object \nsort   – (Optional) kwarg to specify whether or not to sort the eigenvectors, default is true\n\nOutput:\n\nret    – Returns true if the plane locating is successful, false if otherwise\nplanes – (Optional) kwarg for eigvec -> plane mapping, length(vecs) == Int(size(vecs,1)/2)\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.logpb","page":"Home","title":"NonlinearNormalForm.logpb","text":"logpb(mf::Vector{<:Union{TPS,ComplexTPS}}, mi::Vector{<:Union{TPS,ComplexTPS}}=vars(first(F)))\n\nGiven a final map mf and initial map mi, this function calculates the vector field F such that mf=exp(F⋅∇)mi. If mi is not provided, it is assumed to be the identity.\n\njulia> d = Descriptor(2,10); x = vars()[1]; p = vars()[2];\n\njulia> time = 0.01; k = 2; m = 0.01;\n\njulia> h = p^2/(2m) + 1/2*k*x^2;\n\njulia> hf = getvectorfield(h);\n\njulia> map = exppb(-time*hf);\n\njulia> logpb(map) == -time*hf\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#NonlinearNormalForm.mat_eigen!-Tuple{Matrix{<:Number}}","page":"Home","title":"NonlinearNormalForm.mat_eigen!","text":"mat_eigen!(evecs::Matrix{<:Number}, evals::Vector{<:Number}, mat::Matrix{<:Number}; keep_mat=true, sort=true)\n\nGiven a square matrix mat with an even number of rows/cols, calculates the eigenvectors  and eigenvalues. For complex conjugate pairs, the eigenvectors are normalized so that  conj(vⱼ)*S*vⱼ = +im for odd j, and -im for even j. \n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.moveback_unstable!-Tuple{LinearAlgebra.Eigen}","page":"Home","title":"NonlinearNormalForm.moveback_unstable!","text":"moveback_unstable!(F::Eigen)\n\nThis function moves back eigenvectors with eigenvalues having a zero imaginary component  to the end of the values and vectors arrays in the Eigen struct.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.normalize_eigen!-Tuple{LinearAlgebra.Eigen}","page":"Home","title":"NonlinearNormalForm.normalize_eigen!","text":"normalize_eigen!(F::Eigen)\n\nAssuming the eigenvectors are in complex-conjugate pais, the eigenvectors are  normalized so that conj(vⱼ)*S*vⱼ = +im for odd j, and -im for even j where  S is the skew-symmetric matrix e.g. [0 1; -1 0] for 2D.\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.pb-Tuple{Union{ComplexTPS, TPS}, Union{ComplexTPS, TPS}}","page":"Home","title":"NonlinearNormalForm.pb","text":"pb(f::Union{TPS, ComplexTPS}, g::Union{TPS, ComplexTPS})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q₁, p₁, q₂, p₂, ...), computes the Poisson bracket  of the scalar functions f and g. The Poisson bracket of two functions {f, g} is defined as  Σᵢ (∂f/∂qᵢ)(∂g/∂pᵢ) - (∂g/∂qᵢ)(∂f/∂pᵢ).\n\nExamples\n\njulia> d = Descriptor(4,10);\n\njulia> x = vars(d);\n\njulia> f = (x[1]^2 + x[2]^2)/2 + (x[3]^2 + x[4]^2)/2;\n\njulia> pb(f,x[1])\nTPS:\n  Coefficient              Order     Exponent\n  -1.0000000000000000e+00    1        0    1    0    0\n\n\njulia> pb(f,x[2])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0    0    0\n\n\njulia> pb(f,x[3])\nTPS:\n  Coefficient              Order     Exponent\n  -1.0000000000000000e+00    1        0    0    0    1\n\n\njulia> pb(f,x[4])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    0    1    0\n\n\n\n\n\n","category":"method"},{"location":"#NonlinearNormalForm.ptinv-Tuple{Vector{<:Union{ComplexTPS, TPS}}, Vector{<:Integer}}","page":"Home","title":"NonlinearNormalForm.ptinv","text":"ptinv(ma::Vector{<:Union{TPS,ComplexTPS}}, vars::Vector{<:Integer})\n\nPartially-inverts the map ma, inverting only the variables specified by index in vars.\n\n\n\n\n\n","category":"method"}]
}
